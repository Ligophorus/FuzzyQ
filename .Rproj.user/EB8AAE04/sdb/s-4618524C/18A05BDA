{
    "collab_server" : "",
    "contents" : "#' Apply Fuzzy Quantification of Common and Rare Species to Bootstrap Replicates\n#'\n#' Produce N replicates of the original site by species matrix or dataframe by taking bootstrap\n#'     samples of sites (rows) and apply \\code{fuzzyq} to each replicate.\n#' @param M A matrix or dataframe of species abundaces (columns). Each row represents a site.\n#' @param N Integer. Number of bootsrap replicates desired. Default is 1000.\n#' @param level String. Specifiy the type of metrics to be computed for each bootstrap replicate.\n#'     Either \\code{\"spp\"} or \\code{\"global\"}, corresponding to species or community-level metrics,\n#'     respectively.\n#' @param rm.absent Logical. Whether or not absent species are to be removed from the calculations.\n#' @param sorting Logical. If \\code{TRUE} (the default) species are sorted in the output by ascending\n#'     silhouette widths within each cluster, else species are arranged in the same order as in the\n#'     input matrix or dataframe.\n#' @param daisy.args Arguments to be passed to function \\code{daisy} in package \\code{cluster}.\n#' @param ... Arguments to be passed to function \\code{fanny} in package \\code{cluster}.\n#' @return A list consisting of the following:\n#' \\itemize{\n#'   \\item \\code{bs.rep}{matrix of estimated metrics. Replicates are arranged in rows. If \\code{level = \"spp\"},\n#'     columns represent estimates of Commonness Indices per species. If \\code{level = \"global\"}, columns\n#'     represent estimates of Community level clustering metrics: Average silhouette widths per cluster\n#'     and globally, Mean commonness indices per cluster and Normalized Dunn's coefficient.}\n#'  \\item \\code{level}{Indicates whether the estimates are taken at species (\\code{\"spp\"}) or\n#'     community level (\\code{\"global\"}).}\n#' }\n#' @examples\n#' data(antsA)\n#' FQAnts <- fuzzyq(antsA, sorting = TRUE)\n#' # Estimates of species Commonness Indices by species of 1,000 bootstrap replicates:\n#' BS.FQAnts <- fuzzyqBoot (antsA, N = 1e3, level='spp')\n#' # Estimates of global metrics of 1,000 boostrap replicates:\n#' BS.global <- fuzzyqBoot (antsA, N = 1e3, level='global')\nfuzzyqBoot <- function(M, N = 1e3, level=\"spp\", rm.absent = FALSE,\n                         daisy.args, ...) {\n  if (length(dim(M)) != 2 || !(is.data.frame(M) || is.numeric(M)))\n    stop(\"M is not a vector, a dataframe or a numeric matrix.\")\n  if (level %in% c(\"spp\", \"global\") == FALSE)\n    stop(\"Wrong community level specification.\n         Valid choices are 'spp' or 'global'\")\n  if (rm.absent == TRUE &&\n      length(which(colSums(M) == 0)) != 0)  M <- M[, -which(colSums(M) == 0)]\n  if (length(dim(M)) != 2) stop(\"Insufficent data: only one species\")\n  # Bootstrap matrix by sites (rows)\n  bootSxSP <- function(M) {\n    boot_M <- function(M) {\n      a <- sample(seq_len(nrow(M)), nrow(M), replace = TRUE)\n      M <- M[a, ] # data bootstrapped by rows\n      return(M)\n    }\n    M <- replicate(N, boot_M(M), simplify = FALSE)\n    return(M)\n  }\n  spp.names <- colnames(M)\n  M <- bootSxSP(M)\n  if (missing(daisy.args))\n    M <- suppressWarnings(lapply(M, fuzzyq, rm.absent = FALSE,\n                                 keep.Diss = FALSE, sorting = FALSE, ...)) else\n    M <- suppressWarnings(lapply(M, fuzzyq, rm.absent = FALSE, sorting = FALSE,\n                                 daisy.args = dasiy.args, ...))\n  null.control <- sapply(M, function(x) is.null(x$spp))\n  sum.nulls <- sum(null.control, na.rm = TRUE)\n  if (sum.nulls == N) stop(\"All replicates contained too few species\n                           for fuzzy clustering.\")\n  if (sum.nulls > 0 && sum.nulls < N) {\n    null.replicates <- which(null.control == TRUE)\n    M <- M[-null.replicates]\n    options(warning.length = 2000L)\n    warning(paste(c(\"Replicates\", null.replicates,\n                  \"contained too few species for fuzzy clustering and\n                   have been removed.\"), collapse = \" \"))\n  }\n  if (level == \"spp\") {\n     M <- t(sapply(M, function(x) cbind(x$spp[, \"Common.I\"])))\n     colnames(M) <- spp.names\n  } else {\n     M <- t(sapply(M, function(x) x$global))\n  }\n fq.bs <- list(fq.rep = M, level = level)\n return(fb.bs)\n}\n#Percentile bootstrap CIs function\n.pctCI <- function(M, ci.level) {\n  P1 <- ci.level / 2\n  P2 <- 1 - P1\n  bs.ci <- apply(M, 2, quantile, probs = c(P1, P2), na.rm = TRUE)\n  return(bs.ci)\n}\n#bias-corrected CI function\n.bcCI <- function(bt_x, fq, N = N, ci.level) {\n  z <- qnorm(c(ci.level / 2, 1 - ci.level / 2)) # Std. norm. limits\n  b <- qnorm((sum(bt_x > fq) + sum(bt_x == fq) / 2) / N)\n  p <- pnorm(z - 2 * b) # bias-correct & convert to proportions\n  bs.ci <- quantile(bt_x, probs = p)\n  return(bs.ci)\n}\n#bias-corrected & accelerated CI function\n.bcaCI <- function(bt_x, fq, N = N, ci.level) {\n  # estimate acceleration constant\n  n1 <- N - 1\n  obsn <- fq * N\n  pv <- sapply(1:N, function(x) sapply(bt_x[-x], mean))\n  pv <- rowMeans(pv)\n  pv <- obsn - n1 * pv\n  je <- mean(pv) - pv\n  a <- sum(je^3) / (6 * sum(je^2))^(3 / 2)\n  b <- qnorm((sum(bt_x > fq) + sum(bt_x == fq) / 2) / N) #bias\n  z <- qnorm(c(ci.level / 2, 1 - ci.level / 2)) # Std. norm. limits\n  p <- pnorm((z - b) / (1 - a * (z - b)) - b) # correct & convert to proportions\n  bs.ci <- quantile(bt_x, probs = p)\n  return(bs.ci)\n}\n#' Compute Confidence Intervals of Clustering Metrics\n#'\n#' Computes confidence intervals of clustering metrics based on the bootstrap replicates produced by\n#'     \\code{fuzzyqBoot}.\n#' @param fq.bs A list returned by \\code{fuzzyqBoot}.\n#' @param fq A list of class \\code{fuzzyq} returned by \\code{FuzzyQ::fuzzyq}. Required only if\n#'     \\code{method = \"bc\"} or \\code{method = \"bca\"}.\n#' @param method String. Specify the method to compute confidence intervals. Any of the following:\n#'     \"pct\" (percentile), \"bc\" (bias corrected), \"bca\" (bias corrected and accelerated).\n#' @param c.level Number within [0,1]. Specify the confidence interval level. Default is 0.95.\n#' @return A matrix with upper and lower confidence interval limits of clustering metrics.\n#' @examples\n#' data(antsA)\n#' FQAnts <- fuzzyq(antsA, sorting = TRUE)\n#' # Estimates of species Commonness Indices by species of 1,000 bootstrap replicates:\n#' BS.FQAnts <- fuzzyqBoot (antsA, N = 1e3, level='spp')\n#' # Estimates of global metrics of 1,000 boostrap replicates:\n#' BS.global <- fuzzyqBoot (antsA, N = 1e3, level='global')\n#' ############# PENDING #################\nfuzzyqCI <- function(fq.bs, fq = NULL, method = \"pct\", c.level = 0.95) {\n  M <- fq.bs$fq.rep\n  if (!(is.data.frame(M) || is.numeric(M)))\n    stop(\"M is not a dataframe or a numeric matrix.\")\n  if (\"fuzzyq\" %in% class(fq) == FALSE)\n    stop(\"fq is not a fuzzyq object.\")\n  if (method %in% c(\"pct\", \"bc\", \"bca\") == FALSE)\n    stop(\"Wrong confidence interval specification.\n         Valid choices are 'pct','bc' or 'bca'\")\n  c.level <- 1 - c.level\n  if (method == \"pct\") {\n    BS.CI <- .pctCI(M, ci.level = c.level)\n    colnames(BS.CI) <- colnames(M)\n    rownames(BS.CI) <- c(\"Lower\", \"Upper\")\n    return(BS.CI)\n  } else {\n    if (missing(fq) && method != \"pct\")\n      stop(\"fq required for BC or BCa confidence intervals\")\n    N <- nrow(M)\n    if (fq.bs$level == \"spp\") {\n      fq <- fq$spp\n      fq <- fq[match(colnames(M), rownames(fq)), ]\n      fq <- fq[, 3]} else fq <- fq$global\n    if (length(fq) != ncol(M))\n      stop(\"Number of observed values and bootstrap estimates mismatch\")\n    F2apply <- ifelse(method == \"bc\", .bcCI, .bcaCI)\n    BS.CI <- sapply(seq_len(ncol(M)), function(x) F2apply(M[, x],\n                      fq = fq[x], N = N, ci.level = c.level))\n    colnames(BS.CI) <- colnames(M)\n    rownames(BS.CI) <- c(\"Lower\", \"Upper\")\n    return(BS.CI)\n  }\n}\n",
    "created" : 1594303722276.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1666169640",
    "id" : "18A05BDA",
    "lastKnownWriteTime" : 1595518407,
    "last_content_update" : 1595518407055,
    "path" : "F:/nuvol/FuzzyQ/R/bootstrap_functions.R",
    "project_path" : "R/bootstrap_functions.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}