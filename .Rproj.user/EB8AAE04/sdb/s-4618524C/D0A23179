{
    "collab_server" : "",
    "contents" : "#' Fuzzy Quantification of Common and Rare Species in Ecological Communities\n#'\n#' Perform fuzzy clustering of each species based on its abundance and occupancy.\n#' @param M A Matrix or dataframe of species abundaces (columns). Each row represents a sites or\n#'     sampling unit.\n#' @param nclus Integer. Indicate the number of clusters into which species should be allocated.\n#'     Default is 2 (common and rare).\n#' @param diss String. Specifiy the dissimilarity coefficient to be used. Default is \"gower\".\n#'     The other options are \"euclidean\" and \"manhattan\".\n#' @param rm.absent Logical. Indicate how to treat species absences in the community. If TRUE\n#'     absences are considered as structural; absent species are removed from calculations. If\n#'     FALSE (the default) absences are considered as random; absent species are included in the\n#'     calculations.\n#' @param sorting Logical. If TRUE (the default) species are sorted in the output by ascending\n#'     silhouette widths within each cluster, else species are arranged in the same order as in the\n#'     input matrix or dataframe.\n#' @param keep.Diss Logical. Whether or not the species dissimilarity matrix shoudl be returned. The\n#'     default is FALSE.\n#' @param daisy.args Arguments to be passed to function daisy in package cluster.\n#' @param ... Arguments to be passed to function fanny in package cluster.\n#' @return A list of class fuzzyq with the abundance occupancy of each species, clustering metrics for each species and the whole community, and the species dissimilary matrix (if diss = TRUE).\n#' \\describe{\n#'   \\item{\\code{A_O}}{Abundance-occupancy information for each species}\n#'   \\item{\\code{Diss}}{Object of class dist with pairwise dissimilarities among species based on A_O}\n#'   \\item{\\code{spp}}{Clustering metrics per species: Cluster membership (where 0 and 1 denote allocation\n#'    to the rare and common category, respectively), Silhouette Widths and Commonness Indices)}\n#'   \\item{\\code{global}}{Community level clustering metrics: Average silhouette widths per cluster and globally,\n#'    Mean commonness indices per cluster and Normalized Dunn's coefficient}\n#' }\n#' @examples\n#' data(antsA)\n#' # Data set of 46 ant species colelcted in 100 sites.\n#' FQAnts <- fuzzyq(antsA, sorting = TRUE)\n\nfuzzyq <- function(M, nclus = 2, diss = \"gower\", rm.absent = FALSE,\n                   sorting = TRUE, keep.Diss = FALSE, daisy.args, ...) {\n  if (length(dim(M)) != 2 || !(is.data.frame(M) || is.numeric(M)))\n    stop(\"M is not a dataframe or a numeric matrix.\")\n  if (rm.absent == TRUE &&\n      length(which(colSums(M) == 0)) != 0)  M <- M[, -which(colSums(M) == 0)]\n  if (length(dim(M)) != 2) stop(\"Insufficent data: only one species\")\n  abund <- colMeans(M, na.rm = TRUE)\n  M[M > 0] <- 1\n  occ  <- colMeans(M, na.rm = TRUE)\n  A_O <- cbind(occ, abund)\n  colnames(A_O) <- c(\"frq.occ\", \"m.abund\")\n  if (missing(daisy.args)) D <- cluster::daisy(A_O, metric = diss) else\n    D <- do.call(cluster::daisy, c(list(x = A_O, metric = diss), daisy.args))\n # check that there are at sufficient no. of spp for fanny (k >= n/2-1)\n  n <- attr(D, \"Size\")\n  if (nclus >= n / 2 - 1) {\n    warning(\"Insufficient number of spp. for fuzzy clustering. NULLs produced\")\n    sil.w <- NULL\n    global <- NULL\n    cr.fan <- list(A_O = A_O, spp = sil.w, global = global)\n    if (keep.Diss == TRUE) cr.fan <- append(cr.fan, list(Diss = D), 1)\n  } else {\n    fanclus <- cluster::fanny(D, k = nclus, keep.diss = FALSE,\n                              keep.data = FALSE, ...)\n    sil.w <- fanclus$silinfo$widths[, c(1, 3)]\n    # This part ensures that common and rare are consistently related to\n    # clusters. (Rarest sp. is assumed to belong to rare category)\n    rar.tag <- names(which(A_O[, 1] == min(A_O[, 1])))[1]\n    sil.tag <- which(row.names(sil.w) == rar.tag)\n    # 0 = rare; 1 = common\n    sil.w[which(sil.w[, 1] == sil.w[sil.tag, 1]), 1] <- 0\n    sil.w[which(sil.w[, 1] != sil.w[sil.tag, 1]), 1] <- 1\n    # Ensure that \"membership\" reflects \"commonness\"\n    if (fanclus$membership[which(rownames(fanclus$membership) == rar.tag), 1] <=\n        fanclus$membership[which(rownames(fanclus$membership) == rar.tag), 2])\n    m <- 1 else m <- 2\n    # sort prior to cbind by membership\n    sil.w <- sil.w[row.names(fanclus$membership), ]\n    sil.w <- cbind(sil.w, fanclus$membership[, m])\n    colnames(sil.w)[3] <- \"Common.I\"\n    # sorting options\n    if (sorting == TRUE) {\n      sil.w <- sil.w[order(sil.w[, 1], sil.w[, 2]), ]\n      #order A_O rows as sil.w:\n      A_O <- A_O[match(rownames(sil.w), rownames(A_O)), ]\n    }\n    # compute average sil widths and commoness coeffs\n    sil.w <- as.data.frame(sil.w)\n    silw <- c(mean(sil.w[sil.w$cluster == 0, 2]),\n              mean(sil.w[sil.w$cluster == 1, 2]),\n              mean(sil.w[, 2]))\n    memb <- c(mean(sil.w[sil.w$cluster == 0, 3]),\n              mean(sil.w[sil.w$cluster == 1, 3]))\n    global <- c(silw, memb, fanclus$coeff[2])\n    names(global) <- c(\"silw.rar\", \"silw.com\", \"silw.all\",\n                         \"commI.rar\", \"commI.com\", \"N.Dunn\")\n    cr.fan <- list(A_O = A_O, spp = sil.w, global = global)\n    if (keep.Diss == TRUE) cr.fan <- append(cr.fan, list(Diss = D), 1)\n  }\n  class(cr.fan) <- append(class(cr.fan), \"fuzzyq\")\n  is.sorted <- sorting\n  cr.fan$is.sorted <- is.sorted\n  return(cr.fan)\n}\n",
    "created" : 1594303954666.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3434783986",
    "id" : "D0A23179",
    "lastKnownWriteTime" : 1595504096,
    "last_content_update" : 1595504096415,
    "path" : "F:/nuvol/FuzzyQ/R/fuzzyq.R",
    "project_path" : "R/fuzzyq.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}