{
    "collab_server" : "",
    "contents" : "fuzzyqBoot <- function(M, N, level=\"spp\", rm.absent = FALSE,\n                         daisy.args, ...) {\n  if (length(dim(M)) != 2 || !(is.data.frame(M) || is.numeric(M)))\n    stop(\"M is not a vector, a dataframe or a numeric matrix.\")\n  if (level %in% c(\"spp\", \"global\") == FALSE)\n    stop(\"Wrong community level specification.\n         Valid choices are 'spp' or 'global'\")\n  if (rm.absent == TRUE &&\n      length(which(colSums(M) == 0)) != 0)  M <- M[, -which(colSums(M) == 0)]\n  if (length(dim(M)) != 2) stop(\"Insufficent data: only one species\")\n  # Bootstrap matrix by sites (rows)\n  bootSxSP <- function(M) {\n    boot_M <- function(M) {\n      a <- sample(seq_len(nrow(M)), nrow(M), replace = TRUE)\n      M <- M[a, ] # data bootstrapped by rows\n      return(M)\n    }\n    M <- replicate(N, boot_M(M), simplify = FALSE)\n    return(M)\n  }\n  spp.names <- colnames(M)\n  M <- bootSxSP(M)\n  if (missing(daisy.args))\n    M <- suppressWarnings(lapply(M, fuzzyq, rm.absent = FALSE,\n                                 keep.Diss = FALSE, sorting = FALSE, ...)) else\n    M <- suppressWarnings(lapply(M, fuzzyq, rm.absent = FALSE, sorting = FALSE,\n                                 daisy.args = dasiy.args, ...))\n  null.control <- sapply(M, function(x) is.null(x$spp))\n  sum.nulls <- sum(null.control, na.rm = TRUE)\n  if (sum.nulls == N) stop(\"All replicates contained too few species\n                           for fuzzy clustering.\")\n  if (sum.nulls > 0 && sum.nulls < N) {\n    null.replicates <- which(null.control == TRUE)\n    M <- M[-null.replicates]\n    options(warning.length = 2000L)\n    warning(paste(c(\"Replicates\", null.replicates,\n                  \"contained too few species for fuzzy clustering and\n                   have been removed.\"), collapse = \" \"))\n  }\n  if (level == \"spp\") {\n     M <- t(sapply(M, function(x) cbind(x$spp[, \"Common.I\"])))\n     colnames(M) <- spp.names\n  } else {\n     M <- t(sapply(M, function(x) x$global))\n     }\n return(M)\n}\n#Percentile bootstrap CIs function\n.pctCI <- function(M, ci.level) {\n  P1 <- ci.level / 2\n  P2 <- 1 - P1\n  bs.ci <- apply(M, 2, quantile, probs = c(P1, P2), na.rm = TRUE)\n  return(bs.ci)\n}\n#bias-corrected CI function\n.bcCI <- function(bt_x, fq.obj, N = N, ci.level) {\n  z <- qnorm(c(ci.level / 2, 1 - ci.level / 2)) # Std. norm. limits\n  b <- qnorm((sum(bt_x > fq.obj) + sum(bt_x == fq.obj) / 2) / N)\n  p <- pnorm(z - 2 * b) # bias-correct & convert to proportions\n  bs.ci <- quantile(bt_x, probs = p)\n  return(bs.ci)\n}\n#bias-corrected & accelerated CI function\n.bcaCI <- function(bt_x, fq.obj, N = N, ci.level) {\n  # estimate acceleration constant\n  n1 <- N - 1\n  obsn <- fq.obj * N\n  pv <- sapply(1:N, function(x) sapply(bt_x[-x], mean))\n  pv <- rowMeans(pv)\n  pv <- obsn - n1 * pv\n  je <- mean(pv) - pv\n  a <- sum(je^3) / (6 * sum(je^2))^(3 / 2)\n  b <- qnorm((sum(bt_x > fq.obj) + sum(bt_x == fq.obj) / 2) / N) #bias\n  z <- qnorm(c(ci.level / 2, 1 - ci.level / 2)) # Std. norm. limits\n  p <- pnorm((z - b) / (1 - a * (z - b)) - b) # correct & convert to proportions\n  bs.ci <- quantile(bt_x, probs = p)\n  return(bs.ci)\n}\n\nfuzzyqCI <- function(M, fq.obj, level=\"spp\", method = \"pct\", c.level = 0.95) {\n  if (!(is.data.frame(M) || is.numeric(M)))\n    stop(\"M is not a dataframe or a numeric matrix.\")\n  if (\"fuzzyq\" %in% class(fq.obj) == FALSE)\n    stop(\"fq.obj is not a fuzzyq object.\")\n  if (level %in% c(\"spp\", \"global\") == FALSE)\n    stop(\"Wrong community level specification.\n         Valid choices are 'spp' or 'global'\")\n  if (method %in% c(\"pct\", \"bc\", \"bca\") == FALSE)\n    stop(\"Wrong confidence interval specification.\n         Valid choices are 'pct','bc' or 'bca'\")\n  c.level <- 1 - c.level\n  if (method == \"pct\") {\n    BS.CI <- .pctCI(M, ci.level = c.level)\n    colnames(BS.CI) <- colnames(M)\n    rownames(BS.CI) <- c(\"Lower\", \"Upper\")\n    return(BS.CI)\n  } else {\n    if (missing(fq.obj) && method != \"pct\")\n      stop(\"fq.obj required for BC or BCa confidence intervals\")\n    N <- nrow(M)\n    if (level == \"spp\") {\n      fq.obj <- fq.obj$spp\n      fq.obj <- fq.obj[match(colnames(M), rownames(fq.obj)), ]\n      fq.obj <- fq.obj[, 3]} else fq.obj <- fq.obj$global\n    if (length(fq.obj) != ncol(M))\n      stop(\"Number of observed values and bootstrap estimates mismatch\")\n    F2apply <- ifelse(method == \"bc\", .bcCI, .bcaCI)\n    BS.CI <- sapply(seq_len(ncol(M)), function(x) F2apply(M[, x],\n                      fq.obj = fq.obj[x], N = N, ci.level = c.level))\n    colnames(BS.CI) <- colnames(M)\n    rownames(BS.CI) <- c(\"Lower\", \"Upper\")\n    return(BS.CI)\n  }\n}\n",
    "created" : 1594303722276.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4128055253",
    "id" : "18A05BDA",
    "lastKnownWriteTime" : 1594884475,
    "last_content_update" : 1594884475470,
    "path" : "F:/nuvol/clara/FuzzyQ_R/FuzzyQ/R/bootstrap_functions.R",
    "project_path" : "R/bootstrap_functions.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}